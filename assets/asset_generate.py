#!/usr/bin/python3
# based on https://github.com/DanNixon/GLCD-BitmapConverter (Apache-2.0 licence)

from PIL import Image
import argparse

ASSET_LIST_FILE = 'asset_list.txt'
OUTPUT_C_FILE = '../src/assets/assets.c'
OUTPUT_H_FILE = '../src/assets/assets.h'

assets = []

class Bitmap:
    def __init__(self, width, height, data):
        self.width = width
        self.height = height
        self.data = data

def get_name(filename):
    return filename.split('.')[0]

def load_image(filename):
    image = Image.open(filename, 'r')
    image_data = image.load()
    return image.size[0], image.size[1], image_data

def get_pixel_intensity(pixel, invert=False, max_value=255):
    intensity = 0

    # Pixel is multi channel
    if type(pixel) is list or type(pixel) is tuple:
        for channel_intensity in pixel:
            intensity += channel_intensity
        intensity /= len(pixel)
    # Pixel is single channel
    elif type(pixel) is int or type(pixel) is float:
        intensity = pixel
    # Pixel is magic
    else:
        raise ValueError('Not a clue what format the pixel data is: ' + str(type(pixel)))

    if invert:
        return max_value - intensity
    else:
        return intensity

def get_average_pixel_intensity(width, height, pixel_data, invert):
    avg_intensity = 0

    for x_idx in range(0, width):
        for y_idx in range(0, height):
            avg_intensity += get_pixel_intensity(pixel_data[x_idx, y_idx], invert)

    avg_intensity = avg_intensity / (width * height)
    return avg_intensity


def next_multiple(v, multiple):
    return multiple * ((v + multiple - 1) // multiple)

def create_bitmap(width, height, data):
    threshold = get_average_pixel_intensity(width, height, data, invert=False)
    output = []

    # Generate columnwise data
    for x in range(width):
        byte = 0
        colheight = next_multiple(height, 8)
        for y in range(colheight):
            if y>0 and (y % 8 == 0 or y == colheight-1):
                output.append(byte)
                byte = 0

            if y<height and get_pixel_intensity(data[x, y], False) > threshold:
                byte += 2 ** (0 + (y%8))

    bitmap = Bitmap(width, height, output)
    return bitmap




def process_file(filename):
    name = get_name(filename)
    width, height, image_data = load_image(filename)
    bitmap = create_bitmap(width, height, image_data)
    bitmap.name = name
    assets.append(bitmap)

    print(f"{filename} \t-> bitmap {name} ({width}x{height})")

def generate_asset_h_file(assets):
    hfile = open(OUTPUT_H_FILE, 'w')
    hfile.write('// Autogenerated file\n')

    for asset in assets:
        hfile.write(f"extern nglBitmap {asset.name};\t\t// {asset.width}x{asset.height}\n")

def generate_asset_c_file(assets):
    cfile = open(OUTPUT_C_FILE, 'w')
    cfile.write('// Autogenerated file\n')
    cfile.write('#include "ngl.h"\n')
    BYTES_PER_ROW = 16

    for asset in assets:
        # data
        data_name = asset.name + '_data'
        cfile.write(f'\nconst uint8_t {data_name}[{len(asset.data)}] = {{\n')
        for n,byte in enumerate(asset.data):
            cfile.write(f"0x{byte:02x},")
            if n%BYTES_PER_ROW == BYTES_PER_ROW-1:
                cfile.write('\n')
        cfile.write(f'}};\n')

        # struct
        cfile.write(f'\nnglBitmap {asset.name} = {{{asset.width}, {asset.height}, &{data_name}[0]}};\n')
        



def run():
    asset_files = [line.strip() for line in open(ASSET_LIST_FILE).readlines()]

    for file in asset_files:
        process_file(file)

    generate_asset_c_file(assets)
    generate_asset_h_file(assets)


if __name__ == '__main__':
    run()
